# PIP-423: Add a new admin API to acknowledge a single message

# Background knowledge

*   **Message Identification (MessageId):** In Pulsar, every message is uniquely identified by its `MessageId`, which encapsulates a `ledgerId`, an `entryId`, and optionally a partition index. The combination of `ledgerId` and `entryId` (often represented as a `Position`) uniquely identifies a message's physical storage location within a topic. A producer receives a `MessageId` for each message it successfully sends.
*   **Subscriptions and Cursors:** Each subscription on a topic maintains its own "cursor" which tracks consumption progress. It maintains a `mark-delete position`, indicating that all messages up to that point have been acknowledged.
*   **Individual Acknowledgement:** Pulsar subscriptions support different acknowledgement modes. While cumulative acknowledgement is the default for some types, `Shared` and `Key_Shared` subscriptions heavily rely on **individual acknowledgement**. This allows a consumer to acknowledge a single message, even if it's out of order. When a message is acknowledged individually ahead of the `mark-delete position`, it creates an "acknowledgement hole". The broker's `ManagedCursor` must persistently track these holes to ensure that acknowledged messages are not redelivered after a broker restart.
*   **Delayed Messages:** Pulsar supports scheduling messages for future delivery. This is a primary use case that benefits from this proposal, as it allows a scheduled message to be effectively "cancelled" before its delivery time.
*   **Existing `skip-messages` API:** Pulsar has an admin API to `skip` a specified *number* of messages for a subscription. This is useful for bulk-skipping, but it lacks the precision to target a single, specific message within a large backlog, especially if its exact sequence is unknown.

# Motivation

Operators and SREs occasionally need to intervene in a topic's backlog to handle problematic messages or adapt to changing business requirements. For instance:

*   **Cancelling Scheduled Actions:** A delayed message representing a future task (e.g., a scheduled report or a notification) may become obsolete. The most efficient way to handle this is to prevent its delivery entirely.
*   **Removing Backlogs:** A specific message in a backlog might have a malformed payload that causes consumer applications to crash repeatedly. Removing this single message without affecting valid messages around it is a critical operational capability.
*   **Manual Business Logic Correction:** An event may have been sent that is later determined to be invalid due to external factors. An administrator needs a precise tool to remove this specific event from a subscription's queue.

The existing `skip-messages` API is a blunt instrument, ill-suited for these precise, targeted operations. This proposal introduces a more fine-grained administrative tool to acknowledge a single message by its unique `MessageId`. This provides a robust and reliable way to remove any individual message—delayed or not—from a subscription's backlog.

# Goals

## In Scope

*   Provide a new Admin API endpoint (`acknowledgeMessage`) and corresponding `pulsar-admin` CLI command to individually acknowledge a single message for a subscription.
*   The target message will be identified by its `ledgerId` and `entryId`.
*   The implementation will leverage Pulsar's existing, robust `AckType.Individual` mechanism for persistence and reliability.
*   This feature will only be supported for subscription types that allow individual acknowledgements (e.g., `Shared`, `Key_Shared`).
*   Ensure that once a message is successfully acknowledged via this API, it will not be delivered to any consumer on the targeted subscription.

## Out of Scope

*   Acknowledging a batch of messages by ID in a single command. This proposal focuses on a single message.
*   Automatic acknowledgement across geo-replicated clusters. The command is a per-cluster administrative operation.

# High Level Design

The proposed solution provides a new administrative pathway to trigger Pulsar's existing individual acknowledgement capability on demand.

1.  **Initiate Acknowledgement:** An administrator initiates the action via the new `pulsar-admin topics acknowledgeMessage` command or its corresponding REST API endpoint. The request must specify the topic, the target `ledgerId` and `entryId` of the message, and one or more subscription names.

2.  **Broker Receives Request:** The Pulsar broker that owns the topic partition receives the admin request. It validates the parameters and the administrator's permissions for the specified topic.

3.  **Delegate to Subscription:** For each specified subscription, the broker invokes a new `acknowledgeIndividualMessage` method on the `PersistentSubscription` object.

4.  **Perform Individual Acknowledgement:** Inside the `PersistentSubscription`, the following occurs:
    *   It verifies that the subscription's type is compatible with individual acknowledgement.
    *   It constructs a `Position` object from the provided `ledgerId` and `entryId`.
    *   It calls its internal `acknowledgeMessage()` method with `AckType.Individual` for that single position.

5.  **Persistence and Effect:** This action is functionally identical to a consumer acknowledging the message. The `ManagedCursor` for the subscription records this individual acknowledgement, which is then persisted according to the cluster's configuration.
    *   For a **regular message** in the backlog, it is marked as consumed for that subscription and will not be delivered.
    *   For a **delayed message**, it is marked as consumed before the `DelayedDeliveryTracker` even attempts to schedule it. The message is thus effectively **cancelled**.

This design is simple, robust, and minimally invasive, as it builds upon the broker's proven message acknowledgement foundation.

# Detailed Design

## Design & Implementation Details

1.  **Subscription Interface Extension:**
    The `Subscription` interface is extended with a new default method for this operation.
```java
    public interface Subscription {
        /**
         * Acknowledge a single message for the subscription.
         *
         * @param ledgerId The ledger ID of the message to acknowledge.
         * @param entryId The entry ID of the message to acknowledge.
         * @return A CompletableFuture that completes with true if the request was accepted.
         */
        default CompletableFuture<Boolean> acknowledgeIndividualMessage(long ledgerId, long entryId) {
            return CompletableFuture.completedFuture(false);
        }
    }
```

2.  **PersistentSubscription Implementation:**
    The `PersistentSubscription` class provides the concrete implementation.
```java
    // In PersistentSubscription.java
    @Override
    public CompletableFuture<Boolean> acknowledgeIndividualMessage(long ledgerId, long entryId) {
        // This operation is only valid for subscription types that track individual messages.
        if (Subscription.isCumulativeAckMode(getType())) {
            log.warn("Cannot acknowledge single message on subscription {} of type {} which uses cumulative ack.",
                     getName(), getType());
            return CompletableFuture.completedFuture(false);
        }

        Position position = PositionFactory.create(ledgerId, entryId);
        List<Position> positions = Collections.singletonList(position);
        Map<String, Long> properties = Collections.emptyMap();

        // Acknowledge the single message. This will be persisted in the cursor.
        acknowledgeMessage(positions, AckType.Individual, properties);
        return CompletableFuture.completedFuture(true);
    }
```

3.  **Admin API and Topic Logic:**
    *   New methods (`internalAcknowledgeMessage`, etc.) are added to `PersistentTopicsBase` to orchestrate the operation.
    *   The logic handles fanning out requests to all partitions for a partitioned topic.
    *   For a given topic and subscription, it calls the `acknowledgeMessage(ledgerId, entryId)` method on the corresponding `Subscription` object.

4.  **Authorization:**
    A new `TopicOperation` enum value, `ACKNOWLEDGE_MESSAGE`, is added. This allows the operation to be secured by Pulsar's role-based access control. A client role must be granted the `acknowledge_message` permission on a topic to use this feature.

## Public-facing Changes

### Public API

A new REST Admin API endpoint is added to `PersistentTopics`:

*   **Path (v1):** `POST /admin/v1/persistent/{property}/{cluster}/{namespace}/{topic}/acknowledgeMessage`

```java
    @POST
    @Path("/{property}/{cluster}/{namespace}/{topic}/acknowledgeMessage")
    @ApiOperation(hidden = true, value = "Acknowledge a single message by its message ID on specified subscriptions (or all if none specified).")
    @ApiResponses(value = {
            @ApiResponse(code = 204, message = "Operation successful"),
            @ApiResponse(code = 307, message = "Current broker doesn't serve the namespace of this topic"),
            @ApiResponse(code = 401, message = "Client is not authorized to perform this operation"),
            @ApiResponse(code = 403, message = "Client does not have permission to acknowledge messages on this topic"),
            @ApiResponse(code = 404, message = "Namespace, topic, or subscription does not exist"),
            @ApiResponse(code = 405, message = "Operation not allowed on a non-persistent topic"),
            @ApiResponse(code = 412, message = "Failed to acknowledge message due to invalid parameters or incompatible subscription type"),
            @ApiResponse(code = 500, message = "Internal server error")})
    public void acknowledgeMessage(
            @Suspended final AsyncResponse asyncResponse,
            @ApiParam(value = "Specify the property (tenant)", required = true)
            @PathParam("property") String property,
            @ApiParam(value = "Specify the cluster", required = true)
            @PathParam("cluster") String cluster,
            @ApiParam(value = "Specify the namespace", required = true)
            @PathParam("namespace") String namespace,
            @ApiParam(value = "Specify topic name", required = true)
            @PathParam("topic") @Encoded String encodedTopic,
            @ApiParam(value = "Whether this broker is the authoritative owner of the topic. For internal use.")
            @QueryParam("authoritative") @DefaultValue("false") boolean authoritative,
            @ApiParam(value = "Ledger ID of the message to acknowledge.", required = true)
            @QueryParam("ledgerId") long ledgerId,
            @ApiParam(value = "Entry ID of the message to acknowledge.", required = true)
            @QueryParam("entryId") long entryId,
            @ApiParam(value = "List of subscription names to acknowledge on. If empty or not specified, the operation is applied to all subscriptions.")
            @QueryParam("subscriptionNames") List<String> subscriptionNames) {
        try {
            validateTopicName(property, cluster, namespace, encodedTopic);
            if (ledgerId < 0 || entryId < 0) {
                asyncResponse.resume(new RestException(Response.Status.PRECONDITION_FAILED,
                        "ledgerId and entryId must be non-negative."));
                return;
            }
            List<String> finalSubscriptionNames = (subscriptionNames == null || subscriptionNames.isEmpty())
                    ? null : subscriptionNames;
            internalAcknowledgeMessage(asyncResponse, ledgerId, entryId,
                    finalSubscriptionNames, authoritative);
        } catch (WebApplicationException wae) {
            asyncResponse.resume(wae);
        } catch (Exception e) {
            asyncResponse.resume(new RestException(e));
        }
    }
```

*   **Path (v2):** `POST /admin/v2/persistent/{tenant}/{namespace}/{topic}/acknowledgeMessage`

```java
    @POST
    @Path("/{tenant}/{namespace}/{topic}/acknowledgeMessage")
    @ApiOperation(value = "Acknowledge a single message by its message ID on specified subscriptions (or all if none specified).")
    @ApiResponses(value = {
            @ApiResponse(code = 204, message = "Operation successful"),
            @ApiResponse(code = 307, message = "Current broker doesn't serve the namespace of this topic"),
            @ApiResponse(code = 401, message = "Client is not authorized to perform this operation"),
            @ApiResponse(code = 403, message = "Client does not have permission to acknowledge messages on this topic"),
            @ApiResponse(code = 404, message = "Namespace, topic, or subscription does not exist"),
            @ApiResponse(code = 405, message = "Operation not allowed on a non-persistent topic"),
            @ApiResponse(code = 412, message = "Failed to acknowledge message due to invalid parameters or incompatible subscription type"),
            @ApiResponse(code = 500, message = "Internal server error")})
    public void acknowledgeMessage(
            @Suspended final AsyncResponse asyncResponse,
            @ApiParam(value = "Specify the tenant", required = true)
            @PathParam("tenant") String tenant,
            @ApiParam(value = "Specify the namespace", required = true)
            @PathParam("namespace") String namespace,
            @ApiParam(value = "Specify topic name", required = true)
            @PathParam("topic") @Encoded String encodedTopic,
            @ApiParam(value = "Whether this broker is the authoritative owner of the topic. For internal use.")
            @QueryParam("authoritative") @DefaultValue("false") boolean authoritative,
            @ApiParam(value = "Ledger ID of the message to acknowledge.", required = true)
            @QueryParam("ledgerId") long ledgerId,
            @ApiParam(value = "Entry ID of the message to acknowledge.", required = true)
            @QueryParam("entryId") long entryId,
            @ApiParam(value = "List of subscription names to acknowledge on. If empty or not specified, the operation is applied to all subscriptions.")
            @QueryParam("subscriptionNames") List<String> subscriptionNames) {
        try {
            validateTopicName(tenant, namespace, encodedTopic);
            if (ledgerId < 0 || entryId < 0) {
                asyncResponse.resume(new RestException(Response.Status.PRECONDITION_FAILED,
                        "ledgerId and entryId must be non-negative."));
                return;
            }
            List<String> finalSubscriptionNames = (subscriptionNames == null || subscriptionNames.isEmpty())
                    ? null : subscriptionNames;
            internalAcknowledgeMessage(asyncResponse, ledgerId, entryId,
                    finalSubscriptionNames, authoritative);
        } catch (WebApplicationException wae) {
            asyncResponse.resume(wae);
        } catch (Exception e) {
            asyncResponse.resume(new RestException(e));
        }
    }
```

### Binary protocol

No changes are made to the Pulsar binary protocol.

### Configuration

**No new configuration parameters are introduced. However, this feature's performance and behavior under heavy load are directly influenced by existing `ManagedLedger` configurations that govern the persistence of acknowledgement holes.** 

**Administrators should be aware of these settings if they expect a high volume of message cancellations:**

```
# Max number of "acknowledgment holes" that are going to be persistently stored.
# When acknowledging out of order, a consumer will leave holes that are supposed
# to be quickly filled by acking all the messages. The information of which
# messages are acknowledged is persisted by compressing in "ranges" of messages
# that were acknowledged. After the max number of ranges is reached, the information
# will only be tracked in memory and messages will be redelivered in case of
# crashes.
managedLedgerMaxUnackedRangesToPersist=10000

# Maximum number of partially acknowledged batch messages per subscription that will have their batch
# deleted indexes persisted. Batch deleted index state is handled when acknowledgmentAtBatchIndexLevelEnabled=true.
# When this limit is exceeded, remaining batch message containing the batch deleted indexes will
# only be tracked in memory. In case of broker restarts or load balancing events, the batch
# deleted indexes will be cleared while redelivering the messages to consumers.
managedLedgerMaxBatchDeletedIndexToPersist=10000

# When storing acknowledgement state, choose a more compact serialization format that stores
# individual acknowledgements as a bitmap which is serialized to an array of long values. NOTE: This setting requires
# managedLedgerUnackedRangesOpenCacheSetEnabled=true to be effective.
managedLedgerPersistIndividualAckAsLongArray=true

# When set to true, a BitSet will be used to track acknowledged messages that come after the "mark delete position"
# for each subscription. RoaringBitmap is used as a memory efficient BitSet implementation for the acknowledged
# messages tracking. Unacknowledged ranges are the message ranges excluding the acknowledged messages.
managedLedgerUnackedRangesOpenCacheSetEnabled=true

# Max number of "acknowledgment holes" that can be stored in MetadataStore. If number of unack message range is higher
# than this limit then broker will persist unacked ranges into bookkeeper to avoid additional data overhead into
# MetadataStore.
managedLedgerMaxUnackedRangesToPersistInMetadataStore=1000

# ManagedCursorInfo compression type, option values (NONE, LZ4, ZLIB, ZSTD, SNAPPY).
# If value is NONE, then save the ManagedCursorInfo bytes data directly without compression.
# Using compression reduces the size of persistent cursor (subscription) metadata. This enables using a higher
# managedLedgerMaxUnackedRangesToPersistInMetadataStore value and reduces the overall metadata stored in
# the metadata store such as ZooKeeper.
managedCursorInfoCompressionType=NONE

# ManagedCursorInfo compression size threshold (bytes), only compress metadata when origin size more then this value.
# 0 means compression will always apply.
managedCursorInfoCompressionThresholdInBytes=16384

# ManagedLedgerInfo compression type, option values (NONE, LZ4, ZLIB, ZSTD, SNAPPY).
# If value is invalid or NONE, then save the ManagedLedgerInfo bytes data directly without compression.
# Using compression reduces the size of the persistent topic metadata. When a topic contains a large number of
# individual ledgers in BookKeeper or tiered storage, compression helps prevent the metadata size from exceeding
# the maximum size of a metadata store entry (ZNode in ZooKeeper). This also reduces the overall metadata stored
# in the metadata store such as ZooKeeper.
managedLedgerInfoCompressionType=NONE

# ManagedLedgerInfo compression size threshold (bytes), only compress metadata when origin size more then this value.
# 0 means compression will always apply.
managedLedgerInfoCompressionThresholdInBytes=16384
```

### CLI

A new command is added to the `pulsar-admin topics` tool.

*   **Command:** `acknowledgeMessage`
*   **Synopsis:** `pulsar-admin topics acknowledgeMessage <topic-name> [options]`
*   **Parameters:**
    *   `topic-name` (String, required): The full name of the topic (e.g., `persistent://tenant/namespace/topic`).
*   **Options:**
    *   `-l, --ledgerId <long>` (required): Ledger ID of the message to acknowledge.
    *   `-e, --entryId <long>` (required): Entry ID of the message to acknowledge.
    *   `-s, --subscriptionNames <String>` (required): Comma-separated list of subscription names.
*   **Example:**
    ```bash
    # Acknowledge a specific message for two subscriptions
    pulsar-admin topics acknowledgeMessage persistent://public/default/my-topic \
      --ledgerId 12345 --entryId 100 \
      -s sub1,sub2
    ```

# Backward & Forward Compatibility

## Pulsar Geo-Replication Upgrade & Downgrade/Rollback Considerations

This operation is local to a cluster and a subscription's cursor. To acknowledge a message on a replicated topic in multiple clusters, the admin command must be executed against each cluster. Geo-replication state is not affected.

# Alternatives

# Links

* Mailing List discussion thread: https://lists.apache.org/thread/lo182ztgrkzlq6mbkytj8krd050yvb9w
* Mailing List voting thread:
