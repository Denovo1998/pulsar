# PIP-423: Add Support for Cancelling Individual Delayed Messages

# Background knowledge

*   **Delayed Messages:** Apache Pulsar allows producers to send messages that are scheduled to be delivered to consumers at a specified future time. This is achieved by setting a `deliverAt` or `deliverAfter` timestamp on the message. The broker then holds these messages and only dispatches them to consumers once their scheduled delivery time is reached.
*   **DelayedDeliveryTracker:** For persistent topics, when delayed message delivery is enabled, a `DelayedDeliveryTracker` is used on the broker to manage the schedule of these messages. There are two main implementations:
    *   `InMemoryDelayedDeliveryTracker`: Keeps all delayed message indexes in memory. Suitable for a smaller number of delayed messages.
    *   `BucketDelayedDeliveryTracker`: A more scalable solution that uses a hybrid approach. It keeps recent delayed message indexes in a mutable in-memory bucket and spills older/larger sets of indexes into persistent snapshots stored in BookKeeper (via `BookkeeperBucketSnapshotStorage`). This allows handling a large number of delayed messages without exhausting broker memory. When a snapshot is persisted, it contains `DelayedIndex` entries, each representing a delayed message with its original `ledgerId`, `entryId`, and scheduled `timestamp`.
*   **Message Identification (LedgerId, EntryId):** In Pulsar, messages are stored in ledgers. Each message within a ledger has a unique `entryId`. The combination of `ledgerId` and `entryId` (often represented as `Position`) uniquely identifies a message within a topic.
*   **Current State before this PIP:** Pulsar does not offer a native mechanism to cancel a delayed message once it has been sent by the producer and accepted by the broker. If circumstances change and a scheduled message becomes irrelevant, it would still be delivered at its scheduled time.

# Motivation

In modern event-driven architectures, the ability to react to changing conditions is crucial. While Pulsar's delayed message feature is valuable for scheduling future tasks or deliveries, the lack of a cancellation mechanism presents a limitation.
Use cases where cancellation is important include:
*   An order is placed with delayed processing, but the user cancels the order before processing begins.
*   A scheduled notification becomes obsolete due to a subsequent user action.
*   System alerts scheduled for future delivery are resolved before the delivery time.

Without a cancellation feature, applications might resort to workarounds, such as:
*   Consumers receiving and then filtering/ignoring obsolete delayed messages, which wastes processing resources and bandwidth.
*   Maintaining complex state management on the client-side to track and ignore messages, which is error-prone and doesn't prevent the message from being delivered by the broker.

This proposal aims to introduce a robust mechanism to cancel delayed messages directly at the broker level, preventing their delivery if they are no longer needed.

# Goals

## In Scope

*   Provide a mechanism for users to request the cancellation of a specific delayed message.
*   The cancellation request will target a message identified by its `ledgerId`, `entryId`, and original `deliverAt` timestamp.
*   The cancellation will be applied at the broker's `DelayedDeliveryTracker` level.
*   Introduce a new Admin API endpoint for cancelling delayed messages.
*   Provide a corresponding `pulsar-admin` CLI command.
*   Support cancellation for `BucketDelayedDeliveryTracker`.
*   Ensure that once a message is successfully cancelled, it will not be delivered to consumers.

## Out of Scope

*   Client-side (producer/consumer) API for direct cancellation within application code (cancellation is initiated via Admin API).
*   Complex wildcard-based cancellation (e.g., cancel all messages for a user). Cancellation is per specific message ID.
*   Guaranteed immediate cancellation across geo-replicated clusters (cancellation is primarily a per-cluster operation, though admin command can target partitions).

# High Level Design

The proposed solution introduces a mechanism to mark a specific delayed message for cancellation within the broker's `DelayedDeliveryTracker`.

1.  **Cancellation Request:** A user initiates a cancellation request via a new Pulsar Admin API endpoint. The request must specify the target topic, the `ledgerId` and `entryId` of the delayed message to be cancelled, and its original scheduled `deliverAt` timestamp. The `deliverAt` timestamp helps in locating or scheduling the cancellation appropriately if the message is not immediately found in active memory. Optionally, specific subscription names can be provided; otherwise, the cancellation applies to all subscriptions on the topic.

2.  **Dispatcher Involvement:** The Admin API call on the broker handling the request will identify the relevant topic and its subscriptions. For each subscription, it will interact with the `Dispatcher` associated with it.

3.  **DelayedDeliveryTracker Update:** The `Dispatcher` will delegate the cancellation to its `DelayedDeliveryTracker`.
    *   A new method, `applyDelayOperation(ledgerId, entryId, deliverAt, operationType)`, is introduced in `DelayedDeliveryTracker`. For cancellation, `operationType` will be `CANCEL`.
    *   **`BucketDelayedDeliveryTracker` Logic:**
        *   When a `CANCEL` operation is received:
            1.  It first checks if the target message (`ledgerId`, `entryId`) is currently tracked (i.e., its index bit is set in the mutable or immutable buckets' bitmaps). If found, its index bit is cleared, effectively removing it from being scheduled, and `numberDelayedMessages` is decremented. A record of this cancellation is stored in a `canceledMessages` set.
            2.  If the target message is *not* currently found in the tracker's active indexes (e.g., it's scheduled far in the future and its bucket hasn't been loaded, or it was already delivered/acknowledged), a "cancel command" (a special `DelayedIndex` entry with `DelayedOperationType.CANCEL`) is added to the `lastMutableBucket`. This cancel command is scheduled to be processed approximately `2 * tickTimeMillis` before the original `deliverAt` time of the target message. This ensures the cancel command is loaded and processed before the target message itself would be.
        *   **Persistence of Cancel Commands:** These cancel commands are persisted as part of bucket snapshots. The `DelayedIndex` proto is extended to include an `DelayedOperationType` field (`DELAY` or `CANCEL`).
        *   **Recovery:** During recovery from snapshots, `DelayedIndex` entries of type `CANCEL` are loaded into the `canceledMessages` set. Regular `DELAY` type messages are only added to the scheduling queue if they are not present in `canceledMessages`.
        *   **Dispatch Filtering:** When `getScheduledMessages()` is called to retrieve messages for dispatch, if a message ID from the `sharedBucketPriorityQueue` is found in `canceledMessages`, it is skipped and its index bit removed.
        *   **Cleanup of `canceledMessages`:** To prevent unbounded growth, entries in `canceledMessages` (and the persisted CANCEL commands) will have an expiry mechanism. A `canceledMessagesExpiryQueue` tracks these entries, and they are cleaned up after a certain period (e.g., `original_deliver_at + 2 * tickTimeMillis`) post their relevance.

4.  **Result:** If the cancellation is successfully processed by the tracker, the target delayed message will not be delivered to any consumer on the specified subscriptions.

# Detailed Design

## Design & Implementation Details

### 1. `DelayedOperationType` Enum
A new enum `DelayedOperationType` is defined in `pulsar-broker/src/main/proto/DelayedMessageIndexBucketSegment.proto`:
```protobuf
enum DelayedOperationType {
    DELAY = 0;
    CANCEL = 1;
}
```
This enum is used to differentiate between regular delayed messages and cancellation commands within the `DelayedDeliveryTracker` and its persisted snapshots.

### 2. `DelayedIndex` Proto Modification
The `DelayedIndex` message in `DelayedMessageIndexBucketSegment.proto` is extended:
```protobuf
message DelayedIndex {
    required uint64 timestamp = 1;
    required uint64 ledger_id = 2;
    required uint64 entry_id = 3;
    optional DelayedOperationType delayed_operation_type = 4 [default = DELAY];
}
```

### 3. `DelayedDeliveryTracker` Interface
The `DelayedDeliveryTracker` interface is extended with a new method:
```java
public interface DelayedDeliveryTracker extends AutoCloseable {
    // ...
    boolean applyDelayOperation(long ledgerId, long entryId, long deliverAt, DelayedOperationType operationType);
}
```
*   `ledgerId`, `entryId`: Identify the target delayed message.
*   `deliverAt`: The original scheduled delivery timestamp of the target delayed message.
*   `operationType`: Either `DELAY` (for adding/tracking) or `CANCEL`.

### 4. `BucketDelayedDeliveryTracker` Enhancements
*   **`applyDelayOperation(ledgerId, entryId, deliverAt, DelayedOperationType.CANCEL)`:**
    *   Calls `doCancelOperation(ledgerId, entryId, deliverAt)`.
*   **`doCancelOperation(long ledgerId, long entryId, long deliverAt)`:**
    *   Synchronized method.
    *   Checks if the message `(ledgerId, entryId)` exists using `containsMessage()`.
        *   If **yes**:
            *   Calls `removeIndexBit(ledgerId, entryId)` to remove it from tracking bitmaps.
            *   Adds `(ledgerId, entryId)` to the `canceledMessages` set.
            *   Adds `(ledgerId, entryId)` to `canceledMessagesExpiryQueue`, scheduled to expire at `deliverAt + 2 * tickTimeMillis` (original delivery time of target message + buffer).
            *   Decrements `numberDelayedMessages`.
            *   Returns `true`.
        *   If **no** (message not currently tracked, e.g., too far in future, or already past):
            *   Checks if `deliverAt` (original delivery time) is valid (not in the past relative to cutoff). If invalid, return `false`.
            *   Calculates `cancelTime = Math.max(clock.millis(), deliverAt - (2 * tickTimeMillis))`. This is when the "cancel command" itself should be processed.
            *   Adds a cancel command to `lastMutableBucket`: `lastMutableBucket.addMessage(ledgerId, entryId, cancelTime, DelayedOperationType.CANCEL)`. Note: `ledgerId` and `entryId` here refer to the *target* message. This adds a marker that will be processed at `cancelTime`.
            *   Returns `true`.
*   **`canceledMessages`:** A `ConcurrentLongPairSet` storing `(ledgerId, entryId)` of messages for which cancellation has been processed or requested.
*   **`canceledMessagesExpiryQueue`:** A `TripleLongPriorityQueue` storing `(expiryTimestamp, ledgerId, entryId)` for entries in `canceledMessages`. Used by `canceledMessagesCleanup()`.
*   **`addCanceledMessage(long ledgerId, long entryId, long timestamp)`:** Helper method to add to `canceledMessages` and schedule expiry in `canceledMessagesExpiryQueue`. The `timestamp` here is the reference time for expiry calculation (e.g., CANCEL command's processing time or target message's original delivery time).
*   **Recovery (`recoverBucketSnapshot`)**:
    *   When loading `DelayedIndex` entries from a snapshot:
        *   If `delayed_operation_type` is `CANCEL`, `addCanceledMessage(ledgerId, entryId, timestamp)` is called.
        *   If `delayed_operation_type` is `DELAY` (or not set), it's added to `sharedBucketPriorityQueue` only if `(ledgerId, entryId)` is *not* in `canceledMessages`.
*   **Message Scheduling (`getScheduledMessages`)**:
    *   When peeking messages from `sharedBucketPriorityQueue`:
        *   If `(ledgerId, entryId)` is found in `canceledMessages`, the message is popped, `removeIndexBit()` is called, `numberDelayedMessages` is decremented if applicable, and the message is skipped (not returned for dispatch).
*   **Cleanup (`run()` and `canceledMessagesCleanup()`):**
    *   The `run()` method, called periodically by the timer, now also calls `canceledMessagesCleanup()`.
    *   `canceledMessagesCleanup()`: Iterates `canceledMessagesExpiryQueue`. If an entry's `expiryTimestamp <= clock.millis()`, it's removed from `canceledMessagesExpiryQueue` and `canceledMessages`. This prevents unbounded growth of the `canceledMessages` set.
*   **Clearing State (`clear()`, `close()`):** These methods are updated to also clear/close `canceledMessages` and `canceledMessagesExpiryQueue`.

### 5. `MutableBucket` Enhancements
*   **`addMessage(long ledgerId, long entryId, long deliverAt, DelayedOperationType operationType)`:**
    *   If `operationType` is `CANCEL`:
        *   Adds `(deliverAt, ledgerId, entryId)` to its internal `priorityQueue`. `deliverAt` here is the scheduled processing time for the CANCEL command.
        *   Adds `(ledgerId, entryId)` to its `canceledOperations` set (identifies the target message).
        *   **Crucially, `putIndexBit()` is NOT called for CANCEL operations.** This means CANCEL operations don't contribute to the message count/bitmap of messages to be delivered from this bucket.
*   **Sealing and Persisting (`createImmutableBucketAndAsyncPersistent`)**:
    *   When creating `DelayedIndex` entries for the snapshot from its `priorityQueue`:
        *   It checks if `(ledgerId, entryId)` is in `canceledOperations`. If so, the `DelayedIndex` is marked with `DelayedOperationType.CANCEL`. Otherwise, it's marked `DELAY`.
    *   When moving messages from the first segment of a newly created immutable bucket to the `sharedBucketPriorityQueue`, it only adds them if they are not in `canceledOperations`.
*   **`clearCanceledOperations()`**: Called after an immutable bucket is successfully created and persisted, to clear the `canceledOperations` set in the (now old) mutable bucket.

### 6. `Dispatcher` Interface
The `Dispatcher` interface is extended:
```java
public interface Dispatcher {
    // ...
    default CompletableFuture<Boolean> cancelDelayedMessage(long ledgerId, long entryId, long deliverAt) {
        return CompletableFuture.completedFuture(false); // Default for non-supporting dispatchers
    }
}
```

### 7. `PersistentDispatcherMultipleConsumers`
Implements `cancelDelayedMessage`:
```java
@Override
public CompletableFuture<Boolean> cancelDelayedMessage(long ledgerId, long entryId, long deliverAt) {
    synchronized (this) {
        if (delayedDeliveryTracker.isPresent()) {
            boolean result = delayedDeliveryTracker.get()
                    .applyDelayOperation(ledgerId, entryId, deliverAt, DelayedOperationType.CANCEL);
            // Logging ...
            return CompletableFuture.completedFuture(result);
        } else {
            // Logging ...
            return CompletableFuture.completedFuture(false);
        }
    }
}
```

## Public-facing Changes

### Public API

A new REST Admin API endpoint is added to `PersistentTopics`:

*   **Path (v1):** `POST /admin/v1/persistent/{property}/{cluster}/{namespace}/{topic}/cancelDelayedMessage`

```java
    @POST
    @Path("/{property}/{cluster}/{namespace}/{topic}/cancelDelayedMessage")
    @ApiOperation(hidden = true, value = "Cancel a delayed message on specified subscriptions"
            + " (or all if none specified).")
    @ApiResponses(value = {
            @ApiResponse(code = 204, message = "Operation successful"),
            @ApiResponse(code = 307, message = "Current broker doesn't serve the namespace of this topic"),
            @ApiResponse(code = 401, message = "Don't have permission to administrate resources on this tenant"),
            @ApiResponse(code = 403, message = "Don't have admin permission"),
            @ApiResponse(code = 404, message = "Namespace or topic or subscription does not exist"),
            @ApiResponse(code = 405, message = "Operation not allowed on non-persistent topic"),
            @ApiResponse(code = 412, message = "Failed to cancel delayed message or invalid parameters"),
            @ApiResponse(code = 500, message = "Internal server error")})
    public void cancelDelayedMessage(
            @Suspended final AsyncResponse asyncResponse,
            @ApiParam(value = "Specify the property (tenant)", required = true)
            @PathParam("property") String property,
            @ApiParam(value = "Specify the cluster", required = true)
            @PathParam("cluster") String cluster,
            @ApiParam(value = "Specify the namespace", required = true)
            @PathParam("namespace") String namespace,
            @ApiParam(value = "Specify topic name", required = true)
            @PathParam("topic") @Encoded String encodedTopic,
            @ApiParam(value = "Whether leader broker redirected this call to this broker. For internal use.")
            @QueryParam("authoritative") @DefaultValue("false") boolean authoritative,
            @ApiParam(value = "Ledger ID of the target delayed message", required = true)
            @QueryParam("ledgerId") long ledgerId,
            @ApiParam(value = "Entry ID of the target delayed message", required = true)
            @QueryParam("entryId") long entryId,
            @ApiParam(value = "Original deliverAt time of the target delayed message (in milliseconds from epoch)",
                    required = true)
            @QueryParam("deliverAt") long deliverAt,
            @ApiParam(value = "List of subscription names to cancel on (comma-separated, empty or null for"
                    + " all subscriptions)")
            @QueryParam("subscriptionNames") List<String> subscriptionNames) {
        try {
            validateTopicName(property, cluster, namespace, encodedTopic);
            if (ledgerId < 0 || entryId < 0 || deliverAt <= 0) {
                asyncResponse.resume(new RestException(Response.Status.PRECONDITION_FAILED,
                        "ledgerId, entryId must be non-negative, and deliverAt must be positive."));
                return;
            }
            List<String> finalSubscriptionNames = (subscriptionNames == null || subscriptionNames.isEmpty())
                    ? null : subscriptionNames;
            internalCancelDelayedMessage(asyncResponse, ledgerId, entryId, deliverAt,
                    finalSubscriptionNames, authoritative);
        } catch (WebApplicationException wae) {
            asyncResponse.resume(wae);
        } catch (Exception e) {
            asyncResponse.resume(new RestException(e));
        }
    }
```

*   **Path (v2):** `POST /admin/v2/persistent/{tenant}/{namespace}/{topic}/cancelDelayedMessage`

```java
    @POST
    @Path("/{tenant}/{namespace}/{topic}/cancelDelayedMessage")
    @ApiOperation(value = "Cancel a delayed message on specified subscriptions (or all if none specified).")
    @ApiResponses(value = {
            @ApiResponse(code = 204, message = "Operation successful"),
            @ApiResponse(code = 307, message = "Current broker doesn't serve the namespace of this topic"),
            @ApiResponse(code = 401, message = "Don't have permission to administrate resources on this tenant"),
            @ApiResponse(code = 403, message = "Don't have admin permission"),
            @ApiResponse(code = 404, message = "Namespace or topic or subscription does not exist"),
            @ApiResponse(code = 405, message = "Operation not allowed on non-persistent topic"),
            @ApiResponse(code = 412, message = "Failed to cancel delayed message or invalid parameters"),
            @ApiResponse(code = 500, message = "Internal server error")})
    public void cancelDelayedMessage(
            @Suspended final AsyncResponse asyncResponse,
            @ApiParam(value = "Specify the tenant", required = true)
            @PathParam("tenant") String tenant,
            @ApiParam(value = "Specify the namespace", required = true)
            @PathParam("namespace") String namespace,
            @ApiParam(value = "Specify topic name", required = true)
            @PathParam("topic") @Encoded String encodedTopic,
            @ApiParam(value = "Whether leader broker redirected this call to this broker. For internal use.")
            @QueryParam("authoritative") @DefaultValue("false") boolean authoritative,
            @ApiParam(value = "Ledger ID of the target delayed message", required = true)
            @QueryParam("ledgerId") long ledgerId,
            @ApiParam(value = "Entry ID of the target delayed message", required = true)
            @QueryParam("entryId") long entryId,
            @ApiParam(value = "Original deliverAt time of the target delayed message (in milliseconds from epoch)",
                    required = true)
            @QueryParam("deliverAt") long deliverAt,
            @ApiParam(value = "List of subscription names to cancel on (empty or null for all subscriptions)")
            @QueryParam("subscriptionNames") List<String> subscriptionNames) {
        try {
            validateTopicName(tenant, namespace, encodedTopic);
            if (ledgerId < 0 || entryId < 0 || deliverAt <= 0) {
                asyncResponse.resume(new RestException(Response.Status.PRECONDITION_FAILED,
                        "ledgerId, entryId, and deliverAt must be positive."));
                return;
            }
            List<String> finalSubscriptionNames = (subscriptionNames == null || subscriptionNames.isEmpty())
                    ? null : subscriptionNames;
            internalCancelDelayedMessage(asyncResponse, ledgerId, entryId, deliverAt,
                    finalSubscriptionNames, authoritative);
        } catch (WebApplicationException wae) {
            asyncResponse.resume(wae);
        } catch (Exception e) {
            asyncResponse.resume(new RestException(e));
        }
    }
```

### Binary protocol

pulsar-broker/src/main/proto/DelayedMessageIndexBucketSegment.proto

```protobuf
message DelayedIndex {
    ...
    optional DelayedOperationType delayed_operation_type = 4 [default = DELAY];
}

enum DelayedOperationType {
    DELAY = 0;
    CANCEL = 1;
}
```

### Configuration

### CLI

A new CLI command is added to `pulsar-admin topics`:

*   **Command:** `cancel-delayed-message`
*   **Synopsis:** `pulsar-admin topics cancel-delayed-message <topic-name> [options]`
*   **Parameters:**
    *   `topic-name` (String, required): The name of the topic (e.g., `persistent://tenant/namespace/topic`).
*   **Options:**
    *   `-l, --ledgerId <long>` (required): Ledger ID of the message to cancel.
    *   `-e, --entryId <long>` (required): Entry ID of the message to cancel.
    *   `-t, --deliverAt <long>` (required): Original scheduled delivery time (timestamp in ms from epoch) of the message to cancel.
    *   `-s, --subscriptionNames <String>` (optional): Comma-separated list of subscription names to target. If not specified, applies to all subscriptions.
*   **Example:**
```bash
    pulsar-admin topics cancel-delayed-message persistent://public/default/my-topic \
      --ledgerId 12345 --entryId 100 --deliverAt 1678886400000 \
      --subscriptionNames sub1,sub2
```

# Backward & Forward Compatibility

## Pulsar Geo-Replication Upgrade & Downgrade/Rollback Considerations

*   The `cancelDelayedMessage` operation is performed on a per-cluster basis via the Admin API. It directly modifies the state of the `DelayedDeliveryTracker` in the cluster where the command is executed.
*   Delayed messages themselves are not typically subject to geo-replication of their "delayed" state; they are produced to a specific cluster. The message data might be replicated if the topic is replicated, but its delayed scheduling is local.
*   **Upgrade/Downgrade:**
    *   If different clusters in a geo-replicated setup are on different versions (one with cancellation, one without), a message cancelled in the upgraded cluster will not be automatically cancelled in the non-upgraded cluster. Cancellation would need to be issued to each cluster's admin endpoint separately if desired.
    *   No specific issues related to geo-replication data consistency are expected beyond the per-cluster nature of this operation.

# Alternatives

1.  **Client-Side Filtering (Current Workaround):** Consumers receive all delayed messages and filter out unwanted ones based on application logic.
    *   *Rejected because:* Inefficient, wastes resources, and doesn't prevent broker-level delivery.

2.  **Mark Message with Special Properties (Initial Idea in PR #23907 description/Patch 1):** Send a regular Pulsar message with special properties indicating it's a "cancel marker" for another target message. The `Dispatcher` would inspect message properties.
    *   The PR initially included an implementation (Patch 1/6) using this approach by modifying `AbstractBaseDispatcher` to check for properties like `IS_MARK_DELETE_DELAY_MESSAGE` and `DELAY_CANCELED_MESSAGE_POSITION`.
    *   *Seemingly rejected in favor of current Admin API approach because:* The property-based approach might be less direct and could complicate dispatcher logic. The Admin API provides a more explicit control plane operation.

# Links

* Mailing List discussion thread:
* Mailing List voting thread:
