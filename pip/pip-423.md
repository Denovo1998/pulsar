# PIP-423: Add Support for Cancelling Individual Delayed Messages

# Background knowledge

*   **Delayed Messages:** Apache Pulsar allows producers to send messages that are scheduled to be delivered to consumers at a specified future time. This is achieved by setting a `deliverAt` or `deliverAfter` timestamp on the message. When a topic has delayed message delivery enabled, the broker holds these messages and only dispatches them to a subscription's consumers once their scheduled delivery time is reached. The scheduling logic is managed per subscription.
*   **Message Identification (MessageId):** In Pulsar, every message is uniquely identified by its `MessageId`, which encapsulates a `ledgerId`, an `entryId`, and optionally a partition index. The combination of `ledgerId` and `entryId` (often represented as a `Position`) uniquely identifies a message's physical storage location within a topic. A producer receives a `MessageId` for each message it successfully sends.
*   **Subscriptions and Cursors:** Each subscription on a topic maintains its own "cursor". A cursor tracks the consumption progress for that subscription. It maintains a `mark-delete position`, indicating that all messages up to that point have been acknowledged.
*   **Individual Acknowledgement and Acknowledgement Holes:** Pulsar subscriptions support different acknowledgement modes. While cumulative acknowledgement acknowledges all messages up to a certain point, **individual acknowledgement** allows a consumer to acknowledge a single message, even if it's out of order. When a message is acknowledged individually ahead of the `mark-delete position`, it creates an "acknowledgement hole". The broker's `ManagedCursor` must persistently track these holes to ensure that already-acknowledged messages are not redelivered after a broker restart or cursor re-initialization.
*   **Current State before this PIP:** Pulsar does not offer a native API to cancel a specific delayed message once it has been sent. The only way to prevent its delivery is to have a consumer receive it and then discard it, which is inefficient.

# Motivation

In modern event-driven architectures, the ability to react to changing conditions is crucial. While Pulsar's delayed message feature is valuable for scheduling future tasks or deliveries, the lack of a cancellation mechanism presents a limitation.
Use cases where cancellation is important include:
*   An order is placed with delayed processing, but the user cancels the order before processing begins.
*   A scheduled notification becomes obsolete due to a subsequent user action.
*   System alerts scheduled for future delivery are resolved before the delivery time.

Without a cancellation feature, applications might resort to workarounds, such as:
*   Consumers receiving and then filtering/ignoring obsolete delayed messages, which wastes processing resources and bandwidth.
*   Maintaining complex state management on the client-side to track and ignore messages, which is error-prone and doesn't prevent the message from being delivered by the broker.

This proposal aims to introduce a robust mechanism to cancel delayed messages directly at the subscription level, preventing their delivery if they are no longer needed.

# Goals

## In Scope

*   Provide a new Admin API endpoint and corresponding `pulsar-admin` CLI command to request the cancellation of a single delayed message.
*   The cancellation will be targeted at a specific message on a specific subscription (or all subscriptions of a topic) using the message's `ledgerId` and `entryId`.
*   The core implementation will leverage Pulsar's existing individual message acknowledgement mechanism (`AckType.Individual`) for persistence and reliability.
*   This feature will only be supported for subscriptions that allow individual acknowledgements (e.g., `Shared`, `Key_Shared`). It will not be supported for `Exclusive` or `Failover` subscriptions which use cumulative acknowledgements.
*   Ensure that once a message is successfully cancelled for a subscription, it will not be delivered to any consumer on that subscription.

## Out of Scope

*   A new client-facing API for producers or consumers to directly cancel messages. The cancellation is an administrative action.
*   Automatic cancellation across geo-replicated clusters. The cancellation command is a per-cluster administrative operation.

# High Level Design

The proposed solution re-frames the concept of "cancelling" a delayed message as "pre-acknowledging" it for a given subscription. This leverages the broker's robust, existing infrastructure for handling individual acknowledgements.

1.  **Initiate Cancellation:** A user or operator initiates a cancellation request using a new `pulsar-admin topics cancel-delayed-message` command or its corresponding REST API endpoint. The request must specify the topic, the target `ledgerId` and `entryId` of the message, and optionally, one or more subscription names. If no subscription is specified, the operation will apply to all eligible subscriptions on the topic.

2.  **Broker Receives Request:** The Pulsar broker owning the topic receives the admin request. It validates the parameters and permissions.

3.  **Delegate to Subscription:** For each specified (or discovered) subscription, the broker invokes a new `cancelDelayedMessage` method on the `PersistentSubscription` object.

4.  **Perform Individual Acknowledgement:** Inside the `PersistentSubscription`, the core logic is executed:
    *   It verifies that the subscription type supports individual acknowledgements.
    *   It constructs a `Position` object from the provided `ledgerId` and `entryId`.
    *   It calls the internal `acknowledgeMessage()` method with `AckType.Individual` for that single position.

5.  **Persistence and Effect:** This action is identical to a consumer acknowledging that specific message. The `ManagedCursor` for the subscription records this individual acknowledgement, creating an "acknowledgement hole". This state is persisted to BookKeeper (or ZooKeeper, depending on configuration) just like any other acknowledgement information. When the `DelayedDeliveryTracker` later attempts to schedule this message for delivery, the dispatcher will read from the topic, but the `ManagedCursor` will see that this specific message has already been acknowledged and will therefore skip it, preventing its delivery to any consumer on that subscription.

This design is simple, robust, and minimally invasive, as it relies almost entirely on existing, well-tested broker functionality.

# Detailed Design

## Design & Implementation Details

The implementation centers on adding a new administrative pathway to trigger an existing broker capability (individual acknowledgement).

1.  **Subscription Interface Extension:**
    The `Subscription` interface is extended with a new default method.
    ```java
    public interface Subscription {
        // ...
        default CompletableFuture<Boolean> cancelDelayedMessage(long ledgerId, long entryId) {
            return CompletableFuture.completedFuture(false);
        }
    }
    ```

2.  **PersistentSubscription Implementation:**
    The `PersistentSubscription` class provides the concrete implementation.
    ```java
    // In PersistentSubscription.java
    @Override
    public CompletableFuture<Boolean> cancelDelayedMessage(long ledgerId, long entryId) {
        // This operation is only valid for subscription types that track individual messages.
        if (Subscription.isCumulativeAckMode(getType())) {
            log.warn("Cannot cancel delayed message on subscription {} of type {} which uses cumulative ack.",
                     getName(), getType());
            return CompletableFuture.completedFuture(false);
        }

        Position position = PositionFactory.create(ledgerId, entryId);
        List<Position> positions = Collections.singletonList(position);
        Map<String, Long> properties = Collections.emptyMap();

        // Acknowledge the single message. This will be persisted in the cursor.
        acknowledgeMessage(positions, AckType.Individual, properties);
        return CompletableFuture.completedFuture(true);
    }
    ```

3.  **Admin API and Topic Logic:**
    *   A new `internalCancelDelayedMessage` method is added to `PersistentTopicsBase`.
    *   This method handles the logic for partitioned and non-partitioned topics. For partitioned topics, it fans out the request to each partition.
    *   For a given topic, it retrieves the `PersistentTopic` object. If `subscriptionNames` is not provided, it gets a list of all subscriptions on the topic.
    *   It iterates through the target subscriptions and calls the `cancelDelayedMessage(ledgerId, entryId)` method on each `Subscription` object.

4.  **Authorization:**
    A new `TopicOperation` enum value, `CANCEL_DELAYED_MESSAGE`, is added. This ensures that the operation can be controlled via Pulsar's role-based access control. A client role must be granted the `cancel_delayed_message` permission on a topic to use this feature.

## Public-facing Changes

### Public API

A new REST Admin API endpoint is added to `PersistentTopics`:

*   **Path (v1):** `POST /admin/v1/persistent/{property}/{cluster}/{namespace}/{topic}/cancelDelayedMessage`

```java
    @POST
    @Path("/{property}/{cluster}/{namespace}/{topic}/cancelDelayedMessage")
    @ApiOperation(hidden = true, value = "Cancel a delayed message on specified subscriptions"
            + " (or all if none specified).")
    @ApiResponses(value = {
            @ApiResponse(code = 204, message = "Operation successful"),
            @ApiResponse(code = 307, message = "Current broker doesn't serve the namespace of this topic"),
            @ApiResponse(code = 401, message = "Don't have permission to administrate resources on this tenant"),
            @ApiResponse(code = 403, message = "Don't have admin permission"),
            @ApiResponse(code = 404, message = "Namespace or topic or subscription does not exist"),
            @ApiResponse(code = 405, message = "Operation not allowed on non-persistent topic"),
            @ApiResponse(code = 412, message = "Failed to cancel delayed message or invalid parameters"),
            @ApiResponse(code = 500, message = "Internal server error")})
    public void cancelDelayedMessage(
            @Suspended final AsyncResponse asyncResponse,
            @ApiParam(value = "Specify the property (tenant)", required = true)
            @PathParam("property") String property,
            @ApiParam(value = "Specify the cluster", required = true)
            @PathParam("cluster") String cluster,
            @ApiParam(value = "Specify the namespace", required = true)
            @PathParam("namespace") String namespace,
            @ApiParam(value = "Specify topic name", required = true)
            @PathParam("topic") @Encoded String encodedTopic,
            @ApiParam(value = "Whether leader broker redirected this call to this broker. For internal use.")
            @QueryParam("authoritative") @DefaultValue("false") boolean authoritative,
            @ApiParam(value = "Ledger ID of the target delayed message", required = true)
            @QueryParam("ledgerId") long ledgerId,
            @ApiParam(value = "Entry ID of the target delayed message", required = true)
            @QueryParam("entryId") long entryId,
            @ApiParam(value = "List of subscription names to cancel on (comma-separated, empty or null for"
                    + " all subscriptions)")
            @QueryParam("subscriptionNames") List<String> subscriptionNames) {
        try {
            validateTopicName(property, cluster, namespace, encodedTopic);
            if (ledgerId < 0 || entryId < 0) {
                asyncResponse.resume(new RestException(Response.Status.PRECONDITION_FAILED,
                        "ledgerId, entryId must be non-negative."));
                return;
            }
            List<String> finalSubscriptionNames = (subscriptionNames == null || subscriptionNames.isEmpty())
                    ? null : subscriptionNames;
            internalCancelDelayedMessage(asyncResponse, ledgerId, entryId, finalSubscriptionNames, authoritative);
        } catch (WebApplicationException wae) {
            asyncResponse.resume(wae);
        } catch (Exception e) {
            asyncResponse.resume(new RestException(e));
        }
    }
```

*   **Path (v2):** `POST /admin/v2/persistent/{tenant}/{namespace}/{topic}/cancelDelayedMessage`

```java
    @POST
    @Path("/{tenant}/{namespace}/{topic}/cancelDelayedMessage")
    @ApiOperation(value = "Cancel a delayed message on specified subscriptions (or all if none specified).")
    @ApiResponses(value = {
            @ApiResponse(code = 204, message = "Operation successful"),
            @ApiResponse(code = 307, message = "Current broker doesn't serve the namespace of this topic"),
            @ApiResponse(code = 401, message = "Don't have permission to administrate resources on this tenant"),
            @ApiResponse(code = 403, message = "Don't have admin permission"),
            @ApiResponse(code = 404, message = "Namespace or topic or subscription does not exist"),
            @ApiResponse(code = 405, message = "Operation not allowed on non-persistent topic"),
            @ApiResponse(code = 412, message = "Failed to cancel delayed message or invalid parameters"),
            @ApiResponse(code = 500, message = "Internal server error")})
    public void cancelDelayedMessage(
            @Suspended final AsyncResponse asyncResponse,
            @ApiParam(value = "Specify the tenant", required = true)
            @PathParam("tenant") String tenant,
            @ApiParam(value = "Specify the namespace", required = true)
            @PathParam("namespace") String namespace,
            @ApiParam(value = "Specify topic name", required = true)
            @PathParam("topic") @Encoded String encodedTopic,
            @ApiParam(value = "Whether leader broker redirected this call to this broker. For internal use.")
            @QueryParam("authoritative") @DefaultValue("false") boolean authoritative,
            @ApiParam(value = "Ledger ID of the target delayed message", required = true)
            @QueryParam("ledgerId") long ledgerId,
            @ApiParam(value = "Entry ID of the target delayed message", required = true)
            @QueryParam("entryId") long entryId,
            @ApiParam(value = "List of subscription names to cancel on (empty or null for all subscriptions)")
            @QueryParam("subscriptionNames") List<String> subscriptionNames) {
        try {
            validateTopicName(tenant, namespace, encodedTopic);
            if (ledgerId < 0 || entryId < 0) {
                asyncResponse.resume(new RestException(Response.Status.PRECONDITION_FAILED,
                        "ledgerId, entryId must be positive."));
                return;
            }
            List<String> finalSubscriptionNames = (subscriptionNames == null || subscriptionNames.isEmpty())
                    ? null : subscriptionNames;
            internalCancelDelayedMessage(asyncResponse, ledgerId, entryId,
                    finalSubscriptionNames, authoritative);
        } catch (WebApplicationException wae) {
            asyncResponse.resume(wae);
        } catch (Exception e) {
            asyncResponse.resume(new RestException(e));
        }
    }
```

### Binary protocol

No changes are made to the Pulsar binary protocol.

### Configuration

**No new configuration parameters are introduced. However, this feature's performance and behavior under heavy load are directly influenced by existing `ManagedLedger` configurations that govern the persistence of acknowledgement holes.** 

**Administrators should be aware of these settings if they expect a high volume of delayed message cancellations:**

```
# Max number of "acknowledgment holes" that are going to be persistently stored.
# When acknowledging out of order, a consumer will leave holes that are supposed
# to be quickly filled by acking all the messages. The information of which
# messages are acknowledged is persisted by compressing in "ranges" of messages
# that were acknowledged. After the max number of ranges is reached, the information
# will only be tracked in memory and messages will be redelivered in case of
# crashes.
managedLedgerMaxUnackedRangesToPersist=10000

# Maximum number of partially acknowledged batch messages per subscription that will have their batch
# deleted indexes persisted. Batch deleted index state is handled when acknowledgmentAtBatchIndexLevelEnabled=true.
# When this limit is exceeded, remaining batch message containing the batch deleted indexes will
# only be tracked in memory. In case of broker restarts or load balancing events, the batch
# deleted indexes will be cleared while redelivering the messages to consumers.
managedLedgerMaxBatchDeletedIndexToPersist=10000

# When storing acknowledgement state, choose a more compact serialization format that stores
# individual acknowledgements as a bitmap which is serialized to an array of long values. NOTE: This setting requires
# managedLedgerUnackedRangesOpenCacheSetEnabled=true to be effective.
managedLedgerPersistIndividualAckAsLongArray=true

# When set to true, a BitSet will be used to track acknowledged messages that come after the "mark delete position"
# for each subscription. RoaringBitmap is used as a memory efficient BitSet implementation for the acknowledged
# messages tracking. Unacknowledged ranges are the message ranges excluding the acknowledged messages.
managedLedgerUnackedRangesOpenCacheSetEnabled=true

# Max number of "acknowledgment holes" that can be stored in MetadataStore. If number of unack message range is higher
# than this limit then broker will persist unacked ranges into bookkeeper to avoid additional data overhead into
# MetadataStore.
managedLedgerMaxUnackedRangesToPersistInMetadataStore=1000

# ManagedCursorInfo compression type, option values (NONE, LZ4, ZLIB, ZSTD, SNAPPY).
# If value is NONE, then save the ManagedCursorInfo bytes data directly without compression.
# Using compression reduces the size of persistent cursor (subscription) metadata. This enables using a higher
# managedLedgerMaxUnackedRangesToPersistInMetadataStore value and reduces the overall metadata stored in
# the metadata store such as ZooKeeper.
managedCursorInfoCompressionType=NONE

# ManagedCursorInfo compression size threshold (bytes), only compress metadata when origin size more then this value.
# 0 means compression will always apply.
managedCursorInfoCompressionThresholdInBytes=16384

# ManagedLedgerInfo compression type, option values (NONE, LZ4, ZLIB, ZSTD, SNAPPY).
# If value is invalid or NONE, then save the ManagedLedgerInfo bytes data directly without compression.
# Using compression reduces the size of the persistent topic metadata. When a topic contains a large number of
# individual ledgers in BookKeeper or tiered storage, compression helps prevent the metadata size from exceeding
# the maximum size of a metadata store entry (ZNode in ZooKeeper). This also reduces the overall metadata stored
# in the metadata store such as ZooKeeper.
managedLedgerInfoCompressionType=NONE

# ManagedLedgerInfo compression size threshold (bytes), only compress metadata when origin size more then this value.
# 0 means compression will always apply.
managedLedgerInfoCompressionThresholdInBytes=16384
```

### CLI

A new command is added to the `pulsar-admin topics` tool.

*   **Command:** `cancel-delayed-message`
*   **Synopsis:** `pulsar-admin topics cancel-delayed-message <topic-name> [options]`
*   **Parameters:**
    *   `topic-name` (String, required): The full name of the topic (e.g., `persistent://tenant/namespace/topic`).
*   **Options:**
    *   `-l, --ledgerId <long>` (required): Ledger ID of the message to cancel.
    *   `-e, --entryId <long>` (required): Entry ID of the message to cancel.
    *   `-s, --subscriptionNames <String>` (optional): Comma-separated list of subscription names. If not specified, applies to all subscriptions on the topic.

*   **Example:**
    ```bash
    pulsar-admin topics cancel-delayed-message persistent://public/default/my-orders \
      --ledgerId 12345 --entryId 100 --subscriptionNames my-app-subscription
    ```

# Backward & Forward Compatibility

## Pulsar Geo-Replication Upgrade & Downgrade/Rollback Considerations

The `cancelDelayedMessage` operation is fundamentally a per-cluster operation that modifies a subscription's local cursor. It has no direct interaction with geo-replication.

*   A delayed message's scheduling state is local to the cluster where it is being managed.
*   To cancel a delayed message on a replicated topic across multiple clusters, the admin command must be issued to each cluster individually.

# Alternatives

1.  **Client-Side Filtering (Current Workaround):**

*   **Description:** Consumers receive all delayed messages and filter out unwanted ones based on application logic.
*   **Reason for Rejection:** Inefficient, wastes resources, and doesn't prevent broker-level delivery.

2.  **Mark Message with Special Properties:**

*   **Description:** Send a regular Pulsar message with special properties indicating it's a "cancel marker" for 
   another target message. The `Dispatcher` would inspect message properties. The PR initially included an implementation (Patch 1/6) using this approach by modifying `AbstractBaseDispatcher` to check for properties like `IS_MARK_DELETE_DELAY_MESSAGE` and `DELAY_CANCELED_MESSAGE_POSITION`.
*   **Reason for Rejection:** The property-based approach might be less direct and could complicate dispatcher logic. The Admin API provides a more explicit control plane operation.

3. **In-Tracker Cancellation Commands:**

*   **Description:** This approach involved modifying the `BucketDelayedDeliveryTracker` itself. A new `CANCEL` operation type would be added to the `DelayedIndex` protobuf message. When a cancellation was requested, a new `DelayedIndex` record with this `CANCEL` type would be created and persisted in the bucket snapshots. During dispatch, the tracker would check for these cancel markers and skip delivering the corresponding messages.
*   **Reason for Rejection:** This design introduced a critical reliability problem. If a cancellation request was processed and added to the in-memory `lastMutableBucket`, but the broker crashed before this bucket was sealed and persisted to BookKeeper, the cancellation record would be lost forever. The client would have received a success response, but the message would still be delivered after the broker restarted. Guaranteeing the persistence of this cancel command before returning success would introduce unacceptable latency. The chosen approach of using acknowledgements avoids this by leveraging a proven, robust persistence mechanism.

# Links

* Mailing List discussion thread: https://lists.apache.org/thread/lo182ztgrkzlq6mbkytj8krd050yvb9w
* Mailing List voting thread:
